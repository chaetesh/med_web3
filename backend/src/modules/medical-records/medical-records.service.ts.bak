import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { MedicalRecord, MedicalRecordDocument, RecordType } from './schemas/medical-record.schema';
import { StorageService } from '../storage/storage.service';
import { BlockchainService } from '../blockchain/blockchain.service';

@Injectable()
export class MedicalRecordsService {
  private readonly logger = new Logger(MedicalRecordsService.name);

  constructor(
    @InjectModel(MedicalRecord.name) 
    private medicalRecordModel: Model<MedicalRecordDocument>,
    private readonly storageService: StorageService,
    private readonly blockchainService: BlockchainService,
  ) {}

  /**
   * Create a new medical record
   * @param patientId - ID of the patient
   * @param patientAddress - Blockchain address of the patient
   * @param createdById - ID of the user creating the record
   * @param recordData - Medical record data
   * @param fileBuffer - File content as buffer
   */
  async create(
    patientId: string,
    patientAddress: string,
    createdById: string,
    recordData: {
      title: string;
      description?: string;
      recordType: RecordType;
      recordDate: Date;
      hospitalId?: string;
      metadata?: Record<string, any>;
    },
    fileBuffer: Buffer,
  ): Promise<MedicalRecord> {
    try {
      // Store file on IPFS with encryption
      const { ipfsHash, contentHash } = await this.storageService.storeFile(fileBuffer);
      
      // Generate a unique record ID
      const recordId = `MR-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      
      // Store hash on blockchain
      const txHash = await this.blockchainService.storeRecordHash(
        patientAddress,
        recordId,
        ipfsHash,
        contentHash,
      );
      
      // Create medical record in database
      const newRecord = new this.medicalRecordModel({
        patientId,
        recordType: recordData.recordType,
        title: recordData.title,
        description: recordData.description,
        ipfsHash,
        contentHash,
        blockchainTxHash: txHash,
        createdBy: createdById,
        recordDate: recordData.recordDate,
        hospitalId: recordData.hospitalId,
        isEncrypted: true,
        metadata: recordData.metadata || {},
      });
      
      const savedRecord = await newRecord.save();
      this.logger.log(`Medical record created with ID: ${savedRecord._id}`);
      
      return savedRecord;
    } catch (error) {
      this.logger.error(`Error creating medical record: ${error.message}`, error.stack);
      throw new BadRequestException(`Failed to create medical record: ${error.message}`);
    }
  }

  /**
   * Get all medical records for a patient
   * @param patientId - Patient ID
   */
  async findAllByPatient(patientId: string): Promise<MedicalRecord[]> {
    try {
      return this.medicalRecordModel
        .find({ patientId })
        .populate('createdBy', 'firstName lastName role')
        .sort({ recordDate: -1 })
        .exec();
    } catch (error) {
      this.logger.error(`Error retrieving patient records: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Get all medical records shared with a doctor
   * @param doctorId - Doctor ID
   */
  async findAllSharedWithDoctor(doctorId: string): Promise<MedicalRecord[]> {
    try {
      return this.medicalRecordModel
        .find({ sharedWith: doctorId })
        .populate('patientId', 'firstName lastName')
        .populate('createdBy', 'firstName lastName role')
        .sort({ recordDate: -1 })
        .exec();
    } catch (error) {
      this.logger.error(`Error retrieving shared records: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Get medical record by ID
   * @param recordId - Record ID
   * @param userId - User requesting the record
   * @param userWalletAddress - User's wallet address
   * @param patientWalletAddress - Patient's wallet address
   */
  async findById(
    recordId: string,
    userId: string,
    userWalletAddress?: string,
    patientWalletAddress?: string,
  ): Promise<MedicalRecord> {
    try {
      const record = await this.medicalRecordModel
        .findById(recordId)
        .populate('patientId', 'firstName lastName walletAddress')
        .populate('createdBy', 'firstName lastName role')
        .populate('sharedWith', 'firstName lastName role')
        .exec();
      
      if (!record) {
        throw new NotFoundException(`Medical record with ID ${recordId} not found`);
      }
      
      // Check if user has access to this record
      const hasDBAccess = 
        record.patientId && record.patientId._id && record.patientId._id.toString() === userId ||
        record.createdBy && record.createdBy._id && record.createdBy._id.toString() === userId ||
        record.sharedWith?.some(user => user && user._id && user._id.toString() === userId);
      
      // If user has DB access, return the record
      if (hasDBAccess) {
        return record;
      }
      
      // If no DB access but we have wallet addresses, check blockchain
      if (userWalletAddress && patientWalletAddress) {
        const hasBlockchainAccess = await this.blockchainService.checkAccess(
          userWalletAddress,
          patientWalletAddress,
          record._id ? record._id.toString() : recordId,
        );
        
        if (hasBlockchainAccess) {
          // Add user to sharedWith list if they have blockchain access but not DB access
          await this.medicalRecordModel.findByIdAndUpdate(
            recordId,
            { $addToSet: { sharedWith: userId } },
            { new: true }
          );
          return record;
        }
      }
      
      throw new BadRequestException('You do not have access to this medical record');
    } catch (error) {
      this.logger.error(`Error retrieving medical record: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Get medical record file content
   * @param recordId - Record ID
   * @param userId - User requesting the file
   * @param userWalletAddress - User's wallet address
   * @param patientWalletAddress - Patient's wallet address
   */
  async getRecordFile(
    recordId: string,
    userId: string,
    userWalletAddress?: string,
    patientWalletAddress?: string,
  ): Promise<Buffer> {
    try {
      // First check if user has access
      const record = await this.findById(
        recordId,
        userId,
        userWalletAddress,
        patientWalletAddress
      );
      
      // Retrieve file from IPFS
      const fileBuffer = await this.storageService.retrieveFile(record.ipfsHash);
      
      // Verify file integrity using blockchain
      const isVerified = await this.blockchainService.verifyRecord(
        record._id ? record._id.toString() : recordId,
        record.contentHash
      );
      
      if (!isVerified) {
        this.logger.warn(`Record integrity verification failed for ${recordId}`);
      }
      
      return fileBuffer;
    } catch (error) {
      this.logger.error(`Error retrieving record file: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Share a medical record with another user
   * @param recordId - Record ID
   * @param patientId - Patient ID
   * @param patientAddress - Patient's wallet address
   * @param userToShareWithId - User to share with ID
   * @param userToShareWithAddress - User to share with wallet address
   * @param expirationTime - When access should expire (unix timestamp)
   */
  async shareRecord(
    recordId: string,
    userToShareWithId: string,
    userToShareWithAddress: string,
    expirationTime: number
  ): Promise<MedicalRecord> {
    try {
      // Grant access on blockchain
      await this.blockchainService.grantAccess(
        userToShareWithAddress,
        recordId,
        expirationTime
      );
      
      // Update record in database
      const updatedRecord = await this.medicalRecordModel.findByIdAndUpdate(
        recordId,
        { $addToSet: { sharedWith: userToShareWithId } },
        { new: true }
      ).exec();
      
      if (!updatedRecord) {
        throw new Error('Failed to update record');
      }
      
      return updatedRecord as MedicalRecord;

  /**
   * Revoke access to a medical record
   * @param recordId - Record ID
   * @param patientId - Patient ID
   * @param patientAddress - Patient's wallet address
   * @param userToRevokeId - User to revoke access from ID
   * @param userToRevokeAddress - User to revoke access from wallet address
   */
  async revokeAccess(
    recordId: string,
    patientId: string,
    patientAddress: string,
    userToRevokeId: string,
    userToRevokeAddress: string,
  ): Promise<MedicalRecord> {
    try {
      const record = await this.medicalRecordModel.findById(recordId).exec();
      
      if (!record) {
        throw new NotFoundException(`Medical record with ID ${recordId} not found`);
      }
      
      const recordPatientId = record.patientId && typeof record.patientId === 'object' 
        ? record.patientId._id && record.patientId._id.toString() 
        : record.patientId && record.patientId.toString();

      if (recordPatientId !== patientId) {
        throw new BadRequestException('Only the patient can revoke access to this record');
      }
      
      // Revoke access on blockchain
      await this.blockchainService.revokeAccess(
        userToRevokeAddress,
        recordId
      );
      
      // Update record in database
      const updatedRecord = await this.medicalRecordModel.findByIdAndUpdate(
        recordId,
        { $pull: { sharedWith: userToRevokeId } },
        { new: true }
      ).exec();
      
      if (!updatedRecord) {
        throw new Error('Failed to update record');
      }
      
      return updatedRecord as MedicalRecord;
    } catch (error) {
      this.logger.error(`Error revoking access: ${error.message}`, error.stack);
      throw error;
    }
  }

  /**
   * Verify a medical record's integrity
   * @param recordId - Record ID
   */
  async verifyRecord(recordId: string): Promise<{ isVerified: boolean }> {
    try {
      const record = await this.medicalRecordModel.findById(recordId).exec();
      
      if (!record) {
        throw new NotFoundException(`Medical record with ID ${recordId} not found`);
      }
      
      const isVerified = await this.blockchainService.verifyRecord(
        recordId,
        record.contentHash
      );
      
      return { isVerified };
    } catch (error) {
      this.logger.error(`Error verifying record: ${error.message}`, error.stack);
      throw error;
    }
  }
}
